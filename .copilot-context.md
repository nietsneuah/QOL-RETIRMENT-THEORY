# GitHub Copilot Context Helper

This file provides context to GitHub Copilot about the **Modular Portfolio Analysis System** codebase structure, patterns, and conventions.

## Project Overview

**Purpose**: Clean, modular portfolio analysis system with Unix philosophy architecture  
**Language**: Python 3.11+  
**Key Dependencies**: numpy, matplotlib, pandas, scipy, seaborn  
**Architecture**: 6-step modular pipeline with true separation of concerns  

## üö® CRITICAL: Python Environment Requirements

**ALWAYS use the conda `portfolio-sim` environment for ALL Python operations:**

```bash
# REQUIRED: Activate conda environment first
conda activate portfolio-sim

# Verify activation (should show portfolio-sim)
conda info | grep "active environment"

# Then run modular commands
./portfolio-input --format=simple < portfolio.json
./portfolio-strategy --strategy=balanced < portfolio.json
```

### **Environment Details**
- **Environment name**: `portfolio-sim`
- **Python version**: 3.11.13
- **Location**: `/opt/anaconda3/envs/portfolio-sim/bin/python`
- **Key packages**: numpy 2.3.2, pandas 2.3.2, matplotlib 3.10.6, scipy 1.16.1

### **Environment Verification**
```bash
# Check that you're in the correct environment
which python
# Should output: /opt/anaconda3/envs/portfolio-sim/bin/python

python --version  
# Should output: Python 3.11.13

# Test key packages
python -c "import numpy, matplotlib, pandas, scipy; print('All packages imported successfully')"
```

### **‚ö†Ô∏è IMPORTANT NOTES**
- **NEVER use system Python** or other environments
- **ALWAYS activate conda first** before running any Python command
- **Verify environment** with `which python` if unsure
- **All modular scripts require** this specific conda environment

## üèóÔ∏è **Modular Architecture (2025)**

### **6-Step Pipeline Structure**
```
STDIN ‚Üí Input ‚Üí Strategy ‚Üí Simulate ‚Üí Withdrawal ‚Üí Summary ‚Üí Reports ‚Üí OUTPUT
```

### **Current Directory Layout**
```
/Users/doug/Dev/Portfolios/
‚îú‚îÄ‚îÄ modular/                    # ‚úÖ NEW: Modular workflow system
‚îÇ   ‚îú‚îÄ‚îÄ portfolio_input.py     # Step 1: Input translator
‚îÇ   ‚îú‚îÄ‚îÄ portfolio_strategy.py  # Step 2: Strategy application
‚îÇ   ‚îú‚îÄ‚îÄ portfolio_simulate.py  # Step 3: Monte Carlo simulation  
‚îÇ   ‚îú‚îÄ‚îÄ portfolio_withdrawal.py # Step 4: Withdrawal analysis
‚îÇ   ‚îú‚îÄ‚îÄ portfolio_summary.py   # Step 5: Summary generation
‚îÇ   ‚îú‚îÄ‚îÄ portfolio_report.py    # Step 6: Reports & visualization
‚îÇ   ‚îî‚îÄ‚îÄ README.md              # Detailed modular documentation
‚îú‚îÄ‚îÄ portfolio-input*            # CLI convenience scripts
‚îú‚îÄ‚îÄ portfolio-strategy*         
‚îú‚îÄ‚îÄ portfolio-simulate*
‚îú‚îÄ‚îÄ portfolio-withdrawal*
‚îú‚îÄ‚îÄ portfolio-summary*
‚îú‚îÄ‚îÄ portfolio-report*
‚îú‚îÄ‚îÄ market_data/               # Legacy market data modules
‚îú‚îÄ‚îÄ portfolio/                 # Legacy portfolio modules
‚îú‚îÄ‚îÄ archive/                   # Archived old system
‚îÇ   ‚îú‚îÄ‚îÄ old_approach/         # All old conflated scripts
‚îÇ   ‚îî‚îÄ‚îÄ documentation/        # Old documentation
‚îî‚îÄ‚îÄ results/                  # Analysis outputs
```

## Key Patterns and Conventions

### **Modular Pipeline Usage**

**Individual Steps:**
```bash
# Step 1: Input translation
echo '{"current_value": 100000}' | ./portfolio-input --format=simple

# Step 2: Strategy application  
./portfolio-strategy --strategy=balanced < portfolio.json

# Step 3: Monte Carlo simulation
./portfolio-simulate --paths=1000 --years=25 < allocated_portfolio.json

# Step 4: Withdrawal analysis
./portfolio-withdrawal --strategy=4pct < simulation_results.json

# Step 5: Summary generation
./portfolio-summary --format=table < analysis_results.json

# Step 6: Reports & visualization
./portfolio-report --format=html < summary.json
```

**Chained Pipeline:**
```bash
# Complete end-to-end analysis
echo '{"current_value": 837650, "timeline": {"years_to_end": 25}}' | \
  ./portfolio-input --format=simple | \
  ./portfolio-strategy --strategy=balanced | \
  ./portfolio-simulate --paths=1000 | \
  ./portfolio-withdrawal --strategy=4pct | \
  ./portfolio-summary --format=table
```

### **Import Patterns for Modular Code**

**For modular scripts:**
```python
#!/usr/bin/env python3
import json
import sys
import argparse
from typing import Dict, Any, List
from datetime import datetime

try:
    import numpy as np
except ImportError:
    print("Error: numpy is required", file=sys.stderr)
    sys.exit(1)
```

**For CLI convenience scripts:**
```python
#!/usr/bin/env python3
import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'modular'))
from portfolio_input import main

if __name__ == "__main__":
    main()
```

### **Standard JSON Data Structures**

#### **Input Format (Step 1 Output)**
```json
{
  "meta": {
    "currency": "USD",
    "as_of": "2025-09-12",
    "format_version": "1.0"
  },
  "portfolio": {
    "current_value": 837650,
    "taxable_value": 143000,
    "ira_value": 482975,
    "roth_value": 54675,
    "accounts": {
      "account_name": {
        "type": "roth_ira",
        "value": 54675
      }
    }
  },
  "timeline": {
    "years_to_retirement": 5,
    "years_to_end": 25,
    "rebalance_frequency_years": 1
  }
}
```

#### **Allocated Portfolio (Step 2 Output)**
```json
{
  "meta": {...},
  "strategy": {
    "name": "Balanced Portfolio",
    "description": "Moderate risk with balanced growth and income",
    "target_allocation": {
      "US_EQUITY": 0.5,
      "INTL_EQUITY": 0.15,
      "BONDS": 0.3,
      "CASH": 0.05
    },
    "asset_location_rules": {
      "tax_optimization": true,
      "equity_preference": ["roth_ira", "traditional_ira", "taxable"]
    }
  },
  "allocated_portfolio": {
    "accounts": {...},
    "total_value": 837650,
    "allocation_summary": {...}
  }
}
```

#### **Simulation Results (Step 3 Output)**
```json
{
  "simulation_results": {
    "paths": [
      {
        "path_id": 0,
        "initial_value": 837650,
        "annual_values": [837650, 891234, ...],
        "final_value": 1250000
      }
    ],
    "summary_statistics": {
      "final_value": {
        "mean": 1200000,
        "median": 1150000,
        "percentiles": {5: 800000, 50: 1150000, 95: 1800000}
      }
    }
  }
}
```

### **Strategy Definitions**

#### **Available Allocation Strategies**
```python
PREDEFINED_STRATEGIES = {
    "aggressive": {
        "name": "Aggressive Growth",
        "allocation": {
            "US_EQUITY": 0.70,
            "INTL_EQUITY": 0.20,
            "BONDS": 0.05,
            "CASH": 0.05
        }
    },
    "balanced": {
        "name": "Balanced Portfolio", 
        "allocation": {
            "US_EQUITY": 0.50,
            "INTL_EQUITY": 0.15,
            "BONDS": 0.30,
            "CASH": 0.05
        }
    },
    "conservative": {
        "name": "Conservative Income",
        "allocation": {
            "US_EQUITY": 0.30,
            "INTL_EQUITY": 0.10,
            "BONDS": 0.50,
            "CASH": 0.10
        }
    }
}
```

#### **Available Withdrawal Strategies**
```python
WITHDRAWAL_STRATEGIES = {
    "4pct": {
        "name": "4% Rule",
        "type": "fixed_percentage",
        "rate": 0.04
    },
    "rmd": {
        "name": "Required Minimum Distribution",
        "type": "rmd_table"
    },
    "dynamic": {
        "name": "Dynamic Withdrawal",
        "type": "dynamic",
        "base_rate": 0.04
    }
}
```

### **Error Handling Patterns**

#### **Modular Script Error Handling**
```python
def main():
    parser = argparse.ArgumentParser(description="Portfolio Component")
    args = parser.parse_args()
    
    try:
        # Read from STDIN
        input_data = sys.stdin.read()
        data = json.loads(input_data)
        
        # Process data
        result = process_data(data, args)
        
        # Output result
        if args.pretty:
            print(json.dumps(result, indent=2))
        else:
            print(json.dumps(result))
            
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
```

#### **Input Validation**
```python
def validate_portfolio_data(data: Dict[str, Any]) -> None:
    """Validate portfolio data structure"""
    required_keys = ["meta", "portfolio", "timeline"]
    for key in required_keys:
        if key not in data:
            raise ValueError(f"Missing required key: {key}")
    
    if data["portfolio"]["current_value"] <= 0:
        raise ValueError("Portfolio value must be positive")
```

## Common Development Workflows

### **Testing Individual Components**
```bash
# Test input translation
echo '{"current_value": 100000}' | ./portfolio-input --format=simple --pretty

# Test strategy application
./portfolio-strategy --list-strategies

# Test simulation (small sample)
./portfolio-simulate --paths=100 --years=10 < test_allocation.json

# Test withdrawal analysis
./portfolio-withdrawal --list-strategies

# Test summary generation
./portfolio-summary --format=table < test_results.json

# Test report generation
./portfolio-report --format=charts --type=distribution < sim_results.json
```

### **Adding New Allocation Strategy**
```python
# In portfolio_strategy.py, add to predefined_strategies:
"my_custom": {
    "name": "My Custom Strategy",
    "description": "Custom allocation strategy",
    "allocation": {
        "US_EQUITY": 0.60,
        "BONDS": 0.35,
        "CASH": 0.05
    },
    "asset_location": {
        "tax_optimization": True
    }
}
```

### **Adding New Withdrawal Strategy**
```python
# In portfolio_withdrawal.py, add to withdrawal_strategies:
"my_withdrawal": {
    "name": "My Withdrawal Strategy",
    "description": "Custom withdrawal approach",
    "type": "custom",
    "parameters": {...}
}
```

### **Creating Custom Input Format**
```python
# In portfolio_input.py, add new format handler:
def translate_my_format(self, input_data: str) -> Dict[str, Any]:
    """Translate my custom format to standard schema"""
    result = self.standard_schema.copy()
    # Custom parsing logic
    return result
```

## CLI Command Reference

### **Available Commands**
- `portfolio-input` - Input format translation
- `portfolio-strategy` - Allocation strategy application
- `portfolio-simulate` - Monte Carlo simulation
- `portfolio-withdrawal` - Withdrawal strategy analysis
- `portfolio-summary` - Summary generation
- `portfolio-report` - Report and chart generation

### **Common Options**
```bash
# Help for any command
./portfolio-[command] --help

# List available options
./portfolio-strategy --list-strategies
./portfolio-withdrawal --list-strategies

# Pretty print JSON output
./portfolio-[command] --pretty

# Specific output formats
./portfolio-summary --format=table
./portfolio-report --format=html --show
```

## File Naming Conventions

### **Generated Output Files**
- Simulation results: `simulation_results_[timestamp].json`
- Withdrawal analysis: `withdrawal_analysis_[timestamp].json`
- Summary reports: `summary_[timestamp].json`
- HTML reports: `portfolio_report_[timestamp].html`
- Charts: `[chart_type]_chart_[timestamp].png`

### **Input Files**
- Portfolio data: `portfolio.json`
- Custom strategies: `custom_strategy.json`
- Historical results: `results/[analysis_type]/[filename]`

## Testing Patterns

### **Component Testing**
```python
def test_component():
    """Test individual component functionality"""
    # Sample input data
    test_input = {
        "portfolio": {"current_value": 100000},
        "timeline": {"years_to_end": 25}
    }
    
    # Process through component
    result = component.process(test_input)
    
    # Validate output
    assert "meta" in result
    assert result["portfolio"]["current_value"] > 0
```

### **Pipeline Testing**
```bash
# Test complete pipeline with small sample
echo '{"current_value": 100000}' | \
  ./portfolio-input --format=simple | \
  ./portfolio-strategy --strategy=balanced | \
  ./portfolio-simulate --paths=10 --years=5 | \
  ./portfolio-withdrawal --strategy=4pct | \
  ./portfolio-summary --metrics-only
```

## Performance Considerations

### **Simulation Optimization**
- Use `--summary-only` for large simulations to reduce memory usage
- Set random seeds (`--seed=42`) for reproducible results
- Start with small path counts (`--paths=100`) for testing
- Use specific years (`--years=10`) for quick validation

### **Memory Management**
- Process large result sets in streaming fashion
- Clear intermediate data structures when not needed
- Use generators for large data iteration
- Monitor memory with large path counts

## Migration from Legacy System

### **From Old .env Configuration**
```bash
# Convert existing .env file
./portfolio-input --format=env > current_portfolio.json
```

### **From Old Scenarios**
```bash
# Recreate old scenarios with new system
./portfolio-strategy --strategy=balanced < portfolio.json > balanced_allocation.json
./portfolio-strategy --strategy=aggressive < portfolio.json > aggressive_allocation.json
```

## Security and Best Practices

### **Data Handling**
- Never commit personal portfolio data
- Use sample/anonymized data for examples
- Sanitize outputs before sharing
- Keep sensitive configuration in gitignored files

### **Code Quality**
- Each component should do one thing well
- Use type hints for all function parameters
- Validate inputs at module boundaries
- Handle errors gracefully with meaningful messages

## Architecture Philosophy

### **Unix Philosophy Applied**
- **Do one thing well**: Each step has single responsibility
- **Work together**: Components chain seamlessly via pipes
- **Universal interface**: JSON format between all components
- **Simple tools**: Each component is independently testable

### **Separation of Concerns**
- **Input**: Data format translation only
- **Strategy**: Allocation strategy application only  
- **Simulation**: Monte Carlo simulation only
- **Withdrawal**: Withdrawal strategy analysis only
- **Summary**: Results summarization only
- **Reports**: Visualization and reporting only

---

*This context file helps GitHub Copilot understand the Modular Portfolio Analysis System structure and generate relevant, consistent code suggestions that follow the clean architectural patterns.*

## Key Patterns and Conventions

### Import Patterns

**For Core Modules (in src/):**
```python
import sys
from pathlib import Path
# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

# Import core modules
from src.core.monte_carlo import run_simulation, STRATEGIES
from src.analysis.generate_summary_report import SimulationReportGenerator
```

**For Scripts (in scripts/):**
```python
import sys
from pathlib import Path
# Add project root to path  
project_root = Path(__file__).parent.parent.parent  # or .parent.parent for scripts/
sys.path.insert(0, str(project_root))

from src.core.monte_carlo import run_simulation
```

**For Test Files:**
```python
# Standard test setup
sys.path.insert(0, str(Path(__file__).parent.parent.parent))
from src.core import monte_carlo
```

### Data Structures

#### Strategy Definition Pattern
```python
STRATEGIES: Dict[str, Dict[str, float]] = {
    "strategy_name": {
        "bonds": 0.45,     # Allocation percentages (sum ‚â§ 1.0)
        "equity": 0.40,
        "tips": 0.10,
        "gold": 0.05,
    }
}
```

#### Simulation Results Pattern  
```python
{
    "strategy": "strategy_name",
    "n_paths": 1200,
    "horizon_years": [configurable],
    "success_prob_4pct": 0.95,           # Success rate under 4% rule
    "expected_final_mean_4pct": 2500000, # Mean final portfolio value
    "final_p10_4pct": 1800000,          # 10th percentile outcome
    "final_p90_4pct": 3200000,          # 90th percentile outcome
    "summary_by_target": {               # Age-based projections
        "70": {"mean": 1400000, "median": 1380000, "p10": 1200000, "p90": 1600000},
        "80": {"mean": 2500000, "median": 2400000, "p10": 1800000, "p90": 3200000}
    }
}
```

### File Naming Conventions

#### Unique Run Identifiers
Format: `YYYYMMDD_HHMMSS_strategy_pathsp_yearsy_hash`
Example: `20250911_120603_balanced_1200p_22y_f4e7394e`

#### Output Files
- `{strategy}.metrics.json` - Key performance metrics
- `{strategy}.csv` - All simulation paths data
- `{strategy}.percentiles.png` - Wealth evolution visualization
- `{run_id}.summary_report.md` - Comprehensive analysis report

### Error Handling Patterns

#### Market Data Fetching
```python
try:
    # Primary: Tiingo API
    data = self.tiingo_client.get_ticker_price(ticker, startDate=start, endDate=end)
except Exception as e:
    logger.warning(f"Tiingo failed for {ticker}: {e}")
    try:
        # Fallback: yfinance
        data = yf.download(ticker, start=start, end=end)
    except Exception as e2:
        logger.error(f"Both Tiingo and yfinance failed for {ticker}")
        raise
```

#### NaN Value Handling
```python
def safe_get(data, key, default=0.0):
    """Safely extract values, handling NaN and None."""
    value = data.get(key, default)
    if value is None or (isinstance(value, float) and math.isnan(value)):
        return default
    return value
```

## Key Configuration Constants

### Simulation Parameters (src/core/monte_carlo.py)
```python
STARTING_VALUE = [configurable]     # From config.BASELINE_PORTFOLIO_VALUE
HORIZON_YEARS = [configurable]      # From config.HORIZON_YEARS (default 20)
N_PATHS = 1200                      # Monte Carlo simulation paths
PERIODS_PER_YEAR = 12               # Monthly simulations
STARTING_AGE = 65                   # Retirement start age
SEED = 12345                        # Random seed for reproducibility
SCENARIO_METHOD = "iid"             # 'iid' or 'block' bootstrap
```

### Configuration Template (public/templates/config_template.py)
```python
BASELINE_PORTFOLIO_VALUE: float = 500_000.00
ALLOCATION_BASELINE: Dict[str, float] = {
    "cash": 0.10, "bonds": 0.40, "equity": 0.40, "tips": 0.05, "gold": 0.05
}
HORIZON_YEARS: int = 20
STRIPS_LADDER_YEARS: List[int] = list(range(2030, 2051))
VALUE_TOLERANCE_ABS: float = 5.00
ALLOCATION_TOLERANCE: float = 0.005
```

### Asset Mappings
```python
TICKERS = {
    "equity": "VTI",     # Total Stock Market
    "bonds": "TFLO",     # Treasury Floating Rate
    "tips": "TIP",       # TIPS (Treasury Inflation-Protected)
    "gold": "GLD",       # Gold ETF
}
```

## Common Code Generation Patterns

### Adding New Strategy
When adding a new portfolio strategy:
1. Add to STRATEGIES dict in `monte_carlo.py`
2. Ensure weights sum to ‚â§ 1.0
3. Follow existing naming conventions
4. Include risk profile classification

### Market Data Integration
For new asset classes:
1. Add ticker to TICKERS mapping
2. Update STRATEGIES to include new asset
3. Ensure data_fetcher.py can handle the ticker
4. Add to static data building process

### Performance Metric Calculation
Standard metrics to calculate:
- Success probability (portfolio survival)
- Final value distribution (P10, P50, P90)
- Drawdown analysis (maximum decline)
- Volatility metrics (annualized)
- Age-based projections

### Visualization Patterns
```python
# Standard plot setup
plt.figure(figsize=(12, 8))
plt.plot(dates, values, alpha=0.7)
plt.title(f"Strategy Analysis - {strategy_name}")
plt.xlabel("Date")
plt.ylabel("Portfolio Value ($)")
plt.grid(True, alpha=0.3)
plt.tight_layout()
```

## Testing and Validation

### Smoke Test Pattern
```python
def test_basic_functionality():
    """Quick validation of core functionality."""
    try:
        # Test market data
        fetcher = MarketDataFetcher(FetcherConfig())
        data = fetcher.fetch_equity_data("VTI", "2023-01-01", "2023-12-31")
        assert len(data) > 200  # Reasonable amount of data
        
        # Test simulation
        results = run_simulation("balanced", STRATEGIES["balanced"], n_paths=10)
        assert results["n_paths"] == 10
        assert "success_prob_4pct" in results
        
        print("‚úÖ All tests passed")
    except Exception as e:
        print(f"‚ùå Test failed: {e}")
```

### Data Validation
- Always check for NaN values in market data
- Validate that portfolio weights sum to ‚â§ 1.0
- Ensure simulation results are reasonable (no negative success rates)
- Cross-check final values against expected ranges

## Common Development Workflows

### Adding a New Strategy
1. **Define in monte_carlo.py:**
```python
STRATEGIES["new_strategy"] = {
    "bonds": 0.40, "equity": 0.50, "tips": 0.05, "gold": 0.05
}
```
2. **Test with smoke test:** `python scripts/testing/smoke_test_monte_carlo.py`
3. **Run full simulation:** `python src/core/monte_carlo.py`
4. **Generate report:** `python src/analysis/generate_summary_report.py`

### Testing Changes
1. **Quick validation:** `python scripts/testing/smoke_test_monte_carlo.py`
2. **Specific tests:** `python scripts/testing/validation/test_*.py`
3. **Performance check:** `python src/analysis/performance_test.py`
4. **Integration test:** `python src/core/fast_monte_carlo.py --demo`

### Debugging Patterns
- **Check logs:** `tail -f monte_carlo.log`
- **Validate config:** `python -c "import config; print(config.BASELINE_PORTFOLIO_VALUE)"`
- **Test market data:** `python scripts/testing/validation/test_tiingo_integration.py`
- **Verify paths:** `python -c "from src.core.monte_carlo import STRATEGIES; print(list(STRATEGIES.keys()))"`

### Security Considerations
- **Never commit config.py** (contains personal data)
- **Use config_template.py** for examples
- **Keep API keys in market_data/Tiingo.txt** (gitignored)
- **Sanitize output** before sharing

## Performance Optimization Guidelines

### Static Data Usage
- Prefer static data files over API calls during simulations
- Cache market data locally using parquet format
- Use vectorized operations with pandas/numpy
- Minimize loops in favor of vectorized calculations

### Memory Management
- Process large datasets in chunks when necessary
- Clear intermediate variables in long-running simulations
- Use generators for large data iteration
- Monitor memory usage with large path counts

## Common Debugging Patterns

### Market Data Issues
```python
# Debug market data fetching
logger.setLevel(logging.DEBUG)
fetcher = MarketDataFetcher(FetcherConfig())
try:
    data = fetcher.fetch_equity_data(ticker, start, end)
    print(f"Fetched {len(data)} records for {ticker}")
    print(data.head())
except Exception as e:
    print(f"Market data error: {e}")
```

### Simulation Debugging
```python
# Debug simulation results
results = run_simulation(strategy_name, weights, n_paths=10)  # Small test
for key, value in results.items():
    if isinstance(value, float) and math.isnan(value):
        print(f"Warning: NaN value for {key}")
    print(f"{key}: {value}")
```

## Integration Points

### External APIs
- **Tiingo**: Primary market data source (requires API key)
- **yfinance**: Fallback market data source
- **FRED**: Economic data (CPI, inflation indicators)

### File System
- **Results directory**: All outputs saved with unique identifiers
- **Cache directory**: Static data and temporary files
- **Config files**: API keys and system settings

## Code Style Guidelines

### Naming Conventions
- **Functions**: snake_case (`calculate_returns`)
- **Classes**: PascalCase (`MarketDataFetcher`)
- **Constants**: UPPER_SNAKE_CASE (`STARTING_VALUE`)
- **Variables**: snake_case (`portfolio_value`)

### Documentation
- Comprehensive docstrings for all public functions
- Type hints for function parameters and returns
- Inline comments for complex calculations
- README updates for new features

---

*This context file helps GitHub Copilot understand the Monte Carlo Portfolio Simulation System structure and generate relevant, consistent code suggestions.*
